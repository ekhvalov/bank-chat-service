// Code generated by MockGen. DO NOT EDIT.
// Source: handlers.go
//
// Generated by this command:
//
//	mockgen -source=handlers.go -destination=mocks/handlers_mocks.gen.go -typed -package=managerv1mocks
//
// Package managerv1mocks is a generated GoMock package.
package managerv1mocks

import (
	context "context"
	reflect "reflect"

	canreceiveproblems "github.com/ekhvalov/bank-chat-service/internal/usecases/manager/can-receive-problems"
	closechat "github.com/ekhvalov/bank-chat-service/internal/usecases/manager/close-chat"
	freehands "github.com/ekhvalov/bank-chat-service/internal/usecases/manager/free-hands"
	getchathistory "github.com/ekhvalov/bank-chat-service/internal/usecases/manager/get-chat-history"
	getchats "github.com/ekhvalov/bank-chat-service/internal/usecases/manager/get-chats"
	sendmessage "github.com/ekhvalov/bank-chat-service/internal/usecases/manager/send-message"
	gomock "go.uber.org/mock/gomock"
)

// MockcanReceiveProblemsUsecase is a mock of canReceiveProblemsUsecase interface.
type MockcanReceiveProblemsUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockcanReceiveProblemsUsecaseMockRecorder
}

// MockcanReceiveProblemsUsecaseMockRecorder is the mock recorder for MockcanReceiveProblemsUsecase.
type MockcanReceiveProblemsUsecaseMockRecorder struct {
	mock *MockcanReceiveProblemsUsecase
}

// NewMockcanReceiveProblemsUsecase creates a new mock instance.
func NewMockcanReceiveProblemsUsecase(ctrl *gomock.Controller) *MockcanReceiveProblemsUsecase {
	mock := &MockcanReceiveProblemsUsecase{ctrl: ctrl}
	mock.recorder = &MockcanReceiveProblemsUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcanReceiveProblemsUsecase) EXPECT() *MockcanReceiveProblemsUsecaseMockRecorder {
	return m.recorder
}

// Handle mocks base method.
func (m *MockcanReceiveProblemsUsecase) Handle(ctx context.Context, req canreceiveproblems.Request) (canreceiveproblems.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", ctx, req)
	ret0, _ := ret[0].(canreceiveproblems.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Handle indicates an expected call of Handle.
func (mr *MockcanReceiveProblemsUsecaseMockRecorder) Handle(ctx, req any) *canReceiveProblemsUsecaseHandleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockcanReceiveProblemsUsecase)(nil).Handle), ctx, req)
	return &canReceiveProblemsUsecaseHandleCall{Call: call}
}

// canReceiveProblemsUsecaseHandleCall wrap *gomock.Call
type canReceiveProblemsUsecaseHandleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *canReceiveProblemsUsecaseHandleCall) Return(arg0 canreceiveproblems.Response, arg1 error) *canReceiveProblemsUsecaseHandleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *canReceiveProblemsUsecaseHandleCall) Do(f func(context.Context, canreceiveproblems.Request) (canreceiveproblems.Response, error)) *canReceiveProblemsUsecaseHandleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *canReceiveProblemsUsecaseHandleCall) DoAndReturn(f func(context.Context, canreceiveproblems.Request) (canreceiveproblems.Response, error)) *canReceiveProblemsUsecaseHandleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockfreeHandsUsecase is a mock of freeHandsUsecase interface.
type MockfreeHandsUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockfreeHandsUsecaseMockRecorder
}

// MockfreeHandsUsecaseMockRecorder is the mock recorder for MockfreeHandsUsecase.
type MockfreeHandsUsecaseMockRecorder struct {
	mock *MockfreeHandsUsecase
}

// NewMockfreeHandsUsecase creates a new mock instance.
func NewMockfreeHandsUsecase(ctrl *gomock.Controller) *MockfreeHandsUsecase {
	mock := &MockfreeHandsUsecase{ctrl: ctrl}
	mock.recorder = &MockfreeHandsUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockfreeHandsUsecase) EXPECT() *MockfreeHandsUsecaseMockRecorder {
	return m.recorder
}

// Handle mocks base method.
func (m *MockfreeHandsUsecase) Handle(ctx context.Context, req freehands.Request) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", ctx, req)
	ret0, _ := ret[0].(error)
	return ret0
}

// Handle indicates an expected call of Handle.
func (mr *MockfreeHandsUsecaseMockRecorder) Handle(ctx, req any) *freeHandsUsecaseHandleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockfreeHandsUsecase)(nil).Handle), ctx, req)
	return &freeHandsUsecaseHandleCall{Call: call}
}

// freeHandsUsecaseHandleCall wrap *gomock.Call
type freeHandsUsecaseHandleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *freeHandsUsecaseHandleCall) Return(arg0 error) *freeHandsUsecaseHandleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *freeHandsUsecaseHandleCall) Do(f func(context.Context, freehands.Request) error) *freeHandsUsecaseHandleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *freeHandsUsecaseHandleCall) DoAndReturn(f func(context.Context, freehands.Request) error) *freeHandsUsecaseHandleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockgetChatsUsecase is a mock of getChatsUsecase interface.
type MockgetChatsUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockgetChatsUsecaseMockRecorder
}

// MockgetChatsUsecaseMockRecorder is the mock recorder for MockgetChatsUsecase.
type MockgetChatsUsecaseMockRecorder struct {
	mock *MockgetChatsUsecase
}

// NewMockgetChatsUsecase creates a new mock instance.
func NewMockgetChatsUsecase(ctrl *gomock.Controller) *MockgetChatsUsecase {
	mock := &MockgetChatsUsecase{ctrl: ctrl}
	mock.recorder = &MockgetChatsUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgetChatsUsecase) EXPECT() *MockgetChatsUsecaseMockRecorder {
	return m.recorder
}

// Handle mocks base method.
func (m *MockgetChatsUsecase) Handle(ctx context.Context, req getchats.Request) (getchats.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", ctx, req)
	ret0, _ := ret[0].(getchats.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Handle indicates an expected call of Handle.
func (mr *MockgetChatsUsecaseMockRecorder) Handle(ctx, req any) *getChatsUsecaseHandleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockgetChatsUsecase)(nil).Handle), ctx, req)
	return &getChatsUsecaseHandleCall{Call: call}
}

// getChatsUsecaseHandleCall wrap *gomock.Call
type getChatsUsecaseHandleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *getChatsUsecaseHandleCall) Return(arg0 getchats.Response, arg1 error) *getChatsUsecaseHandleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *getChatsUsecaseHandleCall) Do(f func(context.Context, getchats.Request) (getchats.Response, error)) *getChatsUsecaseHandleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *getChatsUsecaseHandleCall) DoAndReturn(f func(context.Context, getchats.Request) (getchats.Response, error)) *getChatsUsecaseHandleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockgetChatHistoryUsecase is a mock of getChatHistoryUsecase interface.
type MockgetChatHistoryUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockgetChatHistoryUsecaseMockRecorder
}

// MockgetChatHistoryUsecaseMockRecorder is the mock recorder for MockgetChatHistoryUsecase.
type MockgetChatHistoryUsecaseMockRecorder struct {
	mock *MockgetChatHistoryUsecase
}

// NewMockgetChatHistoryUsecase creates a new mock instance.
func NewMockgetChatHistoryUsecase(ctrl *gomock.Controller) *MockgetChatHistoryUsecase {
	mock := &MockgetChatHistoryUsecase{ctrl: ctrl}
	mock.recorder = &MockgetChatHistoryUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgetChatHistoryUsecase) EXPECT() *MockgetChatHistoryUsecaseMockRecorder {
	return m.recorder
}

// Handle mocks base method.
func (m *MockgetChatHistoryUsecase) Handle(ctx context.Context, req getchathistory.Request) (getchathistory.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", ctx, req)
	ret0, _ := ret[0].(getchathistory.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Handle indicates an expected call of Handle.
func (mr *MockgetChatHistoryUsecaseMockRecorder) Handle(ctx, req any) *getChatHistoryUsecaseHandleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockgetChatHistoryUsecase)(nil).Handle), ctx, req)
	return &getChatHistoryUsecaseHandleCall{Call: call}
}

// getChatHistoryUsecaseHandleCall wrap *gomock.Call
type getChatHistoryUsecaseHandleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *getChatHistoryUsecaseHandleCall) Return(arg0 getchathistory.Response, arg1 error) *getChatHistoryUsecaseHandleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *getChatHistoryUsecaseHandleCall) Do(f func(context.Context, getchathistory.Request) (getchathistory.Response, error)) *getChatHistoryUsecaseHandleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *getChatHistoryUsecaseHandleCall) DoAndReturn(f func(context.Context, getchathistory.Request) (getchathistory.Response, error)) *getChatHistoryUsecaseHandleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockcloseChatUseCase is a mock of closeChatUseCase interface.
type MockcloseChatUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockcloseChatUseCaseMockRecorder
}

// MockcloseChatUseCaseMockRecorder is the mock recorder for MockcloseChatUseCase.
type MockcloseChatUseCaseMockRecorder struct {
	mock *MockcloseChatUseCase
}

// NewMockcloseChatUseCase creates a new mock instance.
func NewMockcloseChatUseCase(ctrl *gomock.Controller) *MockcloseChatUseCase {
	mock := &MockcloseChatUseCase{ctrl: ctrl}
	mock.recorder = &MockcloseChatUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcloseChatUseCase) EXPECT() *MockcloseChatUseCaseMockRecorder {
	return m.recorder
}

// Handle mocks base method.
func (m *MockcloseChatUseCase) Handle(ctx context.Context, req closechat.Request) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", ctx, req)
	ret0, _ := ret[0].(error)
	return ret0
}

// Handle indicates an expected call of Handle.
func (mr *MockcloseChatUseCaseMockRecorder) Handle(ctx, req any) *closeChatUseCaseHandleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockcloseChatUseCase)(nil).Handle), ctx, req)
	return &closeChatUseCaseHandleCall{Call: call}
}

// closeChatUseCaseHandleCall wrap *gomock.Call
type closeChatUseCaseHandleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *closeChatUseCaseHandleCall) Return(arg0 error) *closeChatUseCaseHandleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *closeChatUseCaseHandleCall) Do(f func(context.Context, closechat.Request) error) *closeChatUseCaseHandleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *closeChatUseCaseHandleCall) DoAndReturn(f func(context.Context, closechat.Request) error) *closeChatUseCaseHandleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocksendMessageUseCase is a mock of sendMessageUseCase interface.
type MocksendMessageUseCase struct {
	ctrl     *gomock.Controller
	recorder *MocksendMessageUseCaseMockRecorder
}

// MocksendMessageUseCaseMockRecorder is the mock recorder for MocksendMessageUseCase.
type MocksendMessageUseCaseMockRecorder struct {
	mock *MocksendMessageUseCase
}

// NewMocksendMessageUseCase creates a new mock instance.
func NewMocksendMessageUseCase(ctrl *gomock.Controller) *MocksendMessageUseCase {
	mock := &MocksendMessageUseCase{ctrl: ctrl}
	mock.recorder = &MocksendMessageUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksendMessageUseCase) EXPECT() *MocksendMessageUseCaseMockRecorder {
	return m.recorder
}

// Handle mocks base method.
func (m *MocksendMessageUseCase) Handle(ctx context.Context, req sendmessage.Request) (sendmessage.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", ctx, req)
	ret0, _ := ret[0].(sendmessage.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Handle indicates an expected call of Handle.
func (mr *MocksendMessageUseCaseMockRecorder) Handle(ctx, req any) *sendMessageUseCaseHandleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MocksendMessageUseCase)(nil).Handle), ctx, req)
	return &sendMessageUseCaseHandleCall{Call: call}
}

// sendMessageUseCaseHandleCall wrap *gomock.Call
type sendMessageUseCaseHandleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *sendMessageUseCaseHandleCall) Return(arg0 sendmessage.Response, arg1 error) *sendMessageUseCaseHandleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *sendMessageUseCaseHandleCall) Do(f func(context.Context, sendmessage.Request) (sendmessage.Response, error)) *sendMessageUseCaseHandleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *sendMessageUseCaseHandleCall) DoAndReturn(f func(context.Context, sendmessage.Request) (sendmessage.Response, error)) *sendMessageUseCaseHandleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
